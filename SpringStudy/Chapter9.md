# 9장 스프링 프로젝트 시작하기

## 1. 자바 엔터프라이즈 플랫폼과 스프링 애플리케이션

#### 클라이언트와 백엔트 시스템

가장 많이 사용되는 구조는 클라이언트가 웹 브라우저이고 백엔드 시스템이 DB인 구성이다. 
간단히 'DB를 사용하는 웹 애플리케이션' 이라고 한다. 웹 클라이언트와 DB가 사용되지 않는 시스템은 거의 없으니, 
이를 스프링이 사용되는 애플리케이션의 기본구조라고 생각할 수도 있다.

그렇다고 꼭 클라이언트는 웹 브라우저여야 하며 백엔드 시스템은 DB를 이용해야 하는 것만은 아니다. HTML을 사용하는 표준 웹 클라이언트 외에도 Flex나 X 인터넷 제품처럼 독립적으로 강력한 기능을 가진 RIA 클라이언트가 사용되기도한다. 
또는 HTTP 프로토콜을 이용해 통신하는 다른 엔터프라이즈 시스템일 때도 있다.

자바 서버가 받아들일 수 잇는 방식으로 요청을 보내기만 한다면 어떤 종류의 클라이언트이든 상관이 없다. 

![image](https://user-images.githubusercontent.com/48270067/155311490-eb8f2e21-0644-4cf6-beed-379c4cff5bc9.png)


#### 애플리케이션 서버

스프링으로 만든 애플리케이션을 자바 서버환경에 배포하려면 JavaEE 서버가 필요하다. 
JavaEE 표준을 따르는 애플리케이션 서버는 크게 두 가지로 구분할 수 있다.
* JavaEE의 대부분의 표준 기술을 지원하고 다양한 형태의 모듈로 배포 가능한 완전한 웹 애플리케이션 서버(WAS)
* 웹 모듈의 배포만 가능한 경량급 WAS또는 서블릿/JSP 컨테이너다.

**경량급 WAS/서블릿 컨테이너**

스프링은 기본적으로 톰캣이나 제티 같은 가벼운 서블릿 컨테이너만 있어도 충분하다. 
EJB나 리소스 커넥터, WAS가 제공하는 분산 서비스 등이 굳이 필요하지 않다면 서블릿 컨테이너로도 엔터프라이즈 애플리케이션에 필요한 핵심기능을 모두 이용할 수 있다.



## 2. 애플리케이션 아키텍처

클라이언트와 백엔드 시스템의 종류와 사용 기술, 연동 방법을 결정했다면 시스템 레벨의 아키텍처는 대략 구성된 셈이다. 다음으로 결정할 사항은 스프링 웹 애플리케이션의 아키텍처다.


아키텍처: 어떤 경계 안에 있는 내부 구성요소들이 어떤 책임을 갖고 있고, 어떤 방식으로 서로 관계를 맺고 동작하는지를 구정하는 것
=> 동적인 행위와 깊은 관계가 있다. 


#### 계층형 아키텍처

성격이 다른 모듈이 강하게 결합되어 한데 모여 있으면 한 가지 이유로 변경이 일어날 때 그와 상관없는
요소도 함께 영향을 받게 된다. 따라서 인터페이스와 같은 유연한 경계를 만들어두고 분리하거나 모아주는 작업이 필요하다.

**아키텍처와 SoC**

 성격이 다른 코드를 두 개의 오브젝트로 분리하고, 그 사이에 인터페이스를 두어 유연한 결합을 가질 수 있게 했다. 
또 DI 컨테이너를 둬서 오브젝트끼리는 직접적인 관계를 알지 못하도록 만드는 것이 지금까지 해온 DI를 기반으로한
유연한 설계와 구현 전략이었다. => 오브젝트 레벨에서 분리의 문제에 대해 생각했었다.

 이런 원리는 아키텍처 레벨에서 좀 더 큰 단위에 대해서도 동일하게 적용할 수 있다.
 
  애플리케이션을 구성하는 오브젝트들을 비슷한 성격과 책임을 가진 것들끼리 묶을 수 있다. 나누지 않는다면 코드가 지저분해지는 등 많은
 문제점이 발생한다. 그래서 성격이 다른 것은 아키텍처 분리해주는 게 좋다. 
* 분리된 각 오브젝트는 독자적으로 개발과 테스트가 가능해서 개발과 변경 작업이 모두 빨라질 수 있다. 
* 구현 방법이나 세부 로직은 서로 영향을 주지 않고 변경될 수 있을 만큼 유연하다.

==> 이렇게 책임과 성격이 다른 것을 분리하는 것을 아키텍처 차원에서 **계층형 아키텍처(layered architecture)** 라고 부른다.
(또는 멀티 티어(=계층) 아키텍처 / 3계층 애플리케이션)
* 웹 기반의 엔터프라이즈 애플리케이션은 일반적으로 세 개의 계층을 갖지만 반드시 그런 것은 아니다.


**3계층 아키텍처와 수직계층**

3계층 아키텍처 구분(애플리케이션에서 담당하는 역할에 따라 분류)
* 데이터 엑세스 계층: DB나 레거시 시스템과 연동하는 인터페이스 역할을 함
* 서비스 계층: 비즈니스 로직을 담고 있음
* 프레젠테이션 계층: 주로 웹 기반의 UI를 만들어내고 그 흐름을 관리하는 프레젠테이션 계층으로 구분한다.

![image](https://user-images.githubusercontent.com/48270067/155341577-26d2b4fd-133f-4a94-84bb-f4df05d91d06.png)

=> 각 계층을 부르는 다양한 이름을 정리해둔 그림


<데이터 엑세스 계층>

* DAO 패턴을 보편적으로 사용하기 때문에 DAO 계층이라고도 불린다. 
* DB 외에도 ERP, 레거시 시스템, 메인프레임 등에 접근하는 역할을 하기 때문에 EIS(Enterprise Information System) 계층이라고도 한다. 
* 장기적인 데이터 저장을 목적으로 하는 DB 이용이 주된 책임
* 외부 시스템을 호출하는 것은 기반 계층으로 따로 분류하기도 한다. 

![image](https://user-images.githubusercontent.com/48270067/155341893-1c576fdc-9e5f-43a0-9ab7-c25a9cb20a1c.png)

* 사용 기술에 따라서 다시 세분화된 계층으로 구분될 수 있다. 
  * 추상화 수준에 따른 구분이므로 **수직적인 계층**이라고 부른다.
  * 세로로 배열
* JdbcTemplate을 사용하는 데이터 액세스 계층의 특징은 JdbcTemplate이 추상화를 위한 계층으로 사용돼서 로우레벨의 기반 계층에 존재하는 JDBC와 드라이버, 스프링의 트랜잭션 추상화 서비스의 동기화 기능을 간접적으로 이용하게 만든다는 것이다. 
* 추상화 계층구조를 따른다면 항상 JdbcTemplate을 통해 접근하도록 코드를 작성하는 것이 바람직하다. 추상화 계층은 필요하면 얼마든지 추가할 수 있다. 
* JdbcTemplate 기능과 SqlService의 SQL을 가져오는 기능을 묶어서 더 단순한 방법으로 DAO코드를 작성하고 싶다면 또 하나의 추상계층을 추가할 수 있다.

<서비스 계층>

서비스 계층은 구조로 보자면 가장 단순하다. 잘 만들어진 스프링 애플리케이션의 서비스 계층 클래스는 이상적인 POJO로 작성된다. POJO 만든다면 객체지향적인 설계 기법이 적용된 코드를 통해서 비즈니스 로직의 핵심을 잘 담아내고, 이를 쉽게 테스트하고 유연하게 확장할 수 있다.

서비스 계층은 DAO 계층을 호출하고 이를 활용해서 만들어진다. 때론 데이터 액세스를 위한 기능 외에 서버나 시스템 레벨에서 제공하는 기반 서비스를 활용할 필요도 있다.

서비스 계층은 틀별한 경우가 아니라면 추상화 수직 계층구조를 가질 필요가 없다. 
기술 API를 직접 다루는 코드가 아니기 때문에 기술에 일관된 방식으로 접근하게 하거나 편하게 사용하게 해주는 추상화는 필요없기 때문이다.

시스템 레벨이나 다른 서버에서 제공하는 기반 서비스를 사용할 때도 DAO처럼 독립적인 계층의 서비스를 이용하는 것으로 봐야한다. 

원칙적으로는 서비스 계층 코드가 기반 서비스 계층의 구현에 종속되면 안된다. 
* 서비스 계층의 코드는 추상화된 기반 서비스 인터페이스를 통해서만 접근하도록 만들어서 특정 구현과 기술에 종속성을 제거해야 한다. 
* 또는 AOP를 통해서 서비스 계층의 코드를 침범하지 않고 부가기능을 추가하는 방법을 활용

==> 이상적인 서비스 계층은 데이터 엑세스 및 프레젠테이션 계층이 모두 바뀌어도 유지될 수 있어야한다. 


<프레젠테이션 계층>

이 계층을 가장 복잡한 계층으로 매우 다양한 기술과 프레임워크의 조합을 가질 수 있다. 
웹과 프레젠테이션 기술을 끊임없이 발전하고 새로운 모델이 등장하기 때문이다.
* 클라이언트의 종류와 상관없이 HTTP 프로토콜을 사용하는 서블릿이 바탕이 된다. 
* 다른 계층과 달리 클라이언트까지 그 범위를 확장될 수도 있다. 
* 초기 클라이언트 모델은 단순히 HTML로 만들어진 결과를 사람이 볼 수 있도록 그려주고, 폼을 통해 입력받은 값을 전달하는 것이었다. 
* 하지만 최근에는 점점 많으 프레젠테이션 로직이 클라이언트로 이동하고 있다.

**계층형 아키텍처 설계의 원칙**

오브젝트와 그 관계에 적용했던 대부분의 객체지향 설계의 원칙은 아키텍처 레벨의 계층과 그 관계에도 동일하게 적용될 수 있다. 
각 계층은 응집도가 높으면서 다른 계층과는 낮은 결합도를 유지할 수 있어야한다. 
* 각 계층은 자신의 계층의 책임에만 충실해야하고 자신과 관련된 기술이 아닌 다른 기술 API의 사용을 삼가해야 한다. => 충실한 계층을 만들면 각 계층 사이의 결합도는 자연스럽게 낮아진다. 
* 특정 계층에서 필요한 작업을 다른 계층에게 부탁할 때, 계층 레벨에서 정의한 인터페이스를 통해서 요청하고 다음과 같이 그 인터페이스 메소드에서는 특정 계층의 기술이 드러나면 안된다.

👀!!!!!!!!!!!!!!!!!!!!
프레젠테이션 계층의 오브젝트를 그대로 서비스 계층으로 전달하면 안된다.
계층의 경계를 넘어갈 때는 반드시 특정 계층에 종속되지 않는 오브젝트 형태로 변환해줘야한다. 
==> 그럼 Controller에서 파라미터로 받은 request 객체를 그대로 Service 함수 호출할때 넘겨주면 안된다는 건가???
Mapper 사용??


#### 애플리케이션 정보 아키텍처

엔터프라이즈 시스템은 본질적으로 동시에 많은 작업이 빠르게 수행돼야 하는 시스템이다.

애플리케이션의 주요 상태정보는 클라이언트나 백엔드 시스템에 분산돼서 보관된다. 비교적 장기간 보관되는 상태정보는 주로 DB나 메인프레임 같은 EIS백엔드 시스템에 저장된다. 하나의 업무 작업이 여러 번의 요청과 페이지에 걸쳐 일어나는 경우에 유지돼야 하는 임시 상태정보는 클라이언트에 일시적으로 보관되기도 하고 서버의 사용자별 세션 메모리에 저장되기도 한다.

애플리케이션을 사이에 두고 흘러다니는 정보를 어떤 식으로 다룰지를 경장하는 일도 아키텍처를 결정할 때 매우 중요한 기준이 된다.
* 애플리케이션에 존재하는 정보를 단순히 데이터로 다루는경우
* 애플리케이션에 존재하는 정보를 오브젝트로 다루는 경우

**DB/SQL 중심의 로직 구현 방식**

데이터 중심 구조는 하나의 업무 트랜잭션에 모든 계층의 코드가 종속되는 경향이 특징이다.

이름으로 사용자 정보를 검색하여 사용자의 아이디, 비밀번호, 이름, 가입일자를 보여주는 작업이 하나의 업무 단위가 되면 사용자 조회라는 단위 업무를 위해서만 존재하는 각 계층의 코드가 만들어진다
 이 아키텍처에서 검색 조건은 SQL로 만들어진다. SQL 결과를 맵이나 객체로 프레젠테이션 계층에 전달된다고 했을 때, 서비스 계층은 별로 할 것이 없고, 프레젠테이션 계층의 해당 뷰는 SQL에서 정확히 어떤 필드값을 리턴할지, 어떤 포맷으로 전달하는지 알고 있다. 프레젠테이션 계층에서는 DB에서 돌려준 값을 그대로 사용한다. 
 
 따라서 이런 구조는 **하나의 특정 업무에 모든 계층의 코드가 종속**되며 업무의 내용이 바뀌면 모든 계층의 코드가 함께 변경된다.
 
 
이런 식의 개발 방법과 아키텍처는 자바 기술이 발전하기 이전의 엔터프라이즈 시스템에서 흔히 발견할 수 있다.
2계층 구조에서도 비슷하게 발견할 수 있다.


이런 방식은 **자바 코드를 단지 DB와 웹 화면을 연결해주는 단순한 인터페이스 도구로 전락**시키는 것이다. 자바의 오브젝트는 단지 HTTP 서비스 채널을 만들어고 JDBC를 이용해 DB기능을 사용하게 하는 스크립트 정도로 역할이 축소 된다.

**거대한 서비스 계층의 방식**

DB에서 가져온 데이터가 애플리케이션에 흘러다니는 정보의 중심이 되는 아키텍처이긴 하지만 DB에 저장 프로시저의 사용을
자제하고 복잡한 WQL을 피하면서, 주요 로직은 서비스 계층의 코드에서 처리하도록 만드는 방법





