# 9장 스프링 프로젝트 시작하기

## 1. 자바 엔터프라이즈 플랫폼과 스프링 애플리케이션

### 클라이언트와 백엔트 시스템

가장 많이 사용되는 구조는 클라이언트가 웹 브라우저이고 백엔드 시스템이 DB인 구성이다. 
간단히 'DB를 사용하는 웹 애플리케이션' 이라고 한다. 웹 클라이언트와 DB가 사용되지 않는 시스템은 거의 없으니, 
이를 스프링이 사용되는 애플리케이션의 기본구조라고 생각할 수도 있다.

그렇다고 꼭 클라이언트는 웹 브라우저여야 하며 백엔드 시스템은 DB를 이용해야 하는 것만은 아니다. HTML을 사용하는 표준 웹 클라이언트 외에도 Flex나 X 인터넷 제품처럼 독립적으로 강력한 기능을 가진 RIA 클라이언트가 사용되기도한다. 
또는 HTTP 프로토콜을 이용해 통신하는 다른 엔터프라이즈 시스템일 때도 있다.

자바 서버가 받아들일 수 잇는 방식으로 요청을 보내기만 한다면 어떤 종류의 클라이언트이든 상관이 없다. 

![image](https://user-images.githubusercontent.com/48270067/155311490-eb8f2e21-0644-4cf6-beed-379c4cff5bc9.png)


### 애플리케이션 서버

스프링으로 만든 애플리케이션을 자바 서버환경에 배포하려면 JavaEE 서버가 필요하다. 
JavaEE 표준을 따르는 애플리케이션 서버는 크게 두 가지로 구분할 수 있다.
* JavaEE의 대부분의 표준 기술을 지원하고 다양한 형태의 모듈로 배포 가능한 완전한 웹 애플리케이션 서버(WAS)
* 웹 모듈의 배포만 가능한 경량급 WAS또는 서블릿/JSP 컨테이너다.

**경량급 WAS/서블릿 컨테이너**

스프링은 기본적으로 톰캣이나 제티 같은 가벼운 서블릿 컨테이너만 있어도 충분하다. 
EJB나 리소스 커넥터, WAS가 제공하는 분산 서비스 등이 굳이 필요하지 않다면 서블릿 컨테이너로도 엔터프라이즈 애플리케이션에 필요한 핵심기능을 모두 이용할 수 있다.

**WAS**

성능면에서 대단히 낫지 않더라도 미션 크리티컬한 시스템에서 요구하는 고도의 안정성이나 고성능 시스템에서 안정적인 리소스 관리등 필요가 있다면 상용/오픈소스 WAS를 이용할 수 있다.

또 상대적으로 관리 기능이나 모니터링이 기능이 뛰어나서 여러 대의 서버를 동시에 운영할 때 유리한 점이 많다.



### 스프링 애플리케이션의 배포단위

스프링 애플리케이션은 다음의 세 가지 단위로 배포할 수 있다. 

* 독립 웹모듈
 * 스프링은 보통 war로 패키징된 독립 웹 모듈로 배포된다.
 * 톰캣 같은 서블릿 컨테이너를 쓴다면 독립 웹 모듈이 유일한 방법이다.
 * 가장 단순하고 편리한 배포 단위
* 엔터프라이즈 애플리케이션
 * 스프링 애플리케이션에서 EJB 모듈을 사용하거나 EJB 모듈에서 스프링으로 만든 애플리케이션을 이용해야한다면 EJB와 스프링 웹 모듈을 엔터프라이즈 애플리케이션으로 통합해야한다.
* 백그라운드 서비스 모듈
 * rar
 * 리소스 커넥터를 만들어 배포할 때 사용하는 방식이다.
 * UI를 가질 필요가 없고 서버 내에서 맥그라운드 서비스처럼 동작할 필요가 있다면 rar 모듈로 만들어서 배포할 수 있다. 
 * 이때는 J2EE(Java 2 Platform Enterprise Edition) 1.4나 그 시앙의 표준을 따르는 WAS가 반드시 필요하다.


## 2. 애플리케이션 아키텍처

클라이언트와 백엔드 시스템의 종류와 사용 기술, 연동 방법을 결정했다면 시스템 레벨의 아키텍처는 대략 구성된 셈이다. 다음으로 결정할 사항은 스프링 웹 애플리케이션의 아키텍처다.


아키텍처: 어떤 경계 안에 있는 내부 구성요소들이 어떤 책임을 갖고 있고, 어떤 방식으로 서로 관계를 맺고 동작하는지를 구정하는 것
=> 동적인 행위와 깊은 관계가 있다. 


### 계층형 아키텍처

성격이 다른 모듈이 강하게 결합되어 한데 모여 있으면 한 가지 이유로 변경이 일어날 때 그와 상관없는
요소도 함께 영향을 받게 된다. 따라서 인터페이스와 같은 유연한 경계를 만들어두고 분리하거나 모아주는 작업이 필요하다.

**아키텍처와 SoC**

 성격이 다른 코드를 두 개의 오브젝트로 분리하고, 그 사이에 인터페이스를 두어 유연한 결합을 가질 수 있게 했다. 
또 DI 컨테이너를 둬서 오브젝트끼리는 직접적인 관계를 알지 못하도록 만드는 것이 지금까지 해온 DI를 기반으로한
유연한 설계와 구현 전략이었다. => 오브젝트 레벨에서 분리의 문제에 대해 생각했었다.

 이런 원리는 아키텍처 레벨에서 좀 더 큰 단위에 대해서도 동일하게 적용할 수 있다.
 
  애플리케이션을 구성하는 오브젝트들을 비슷한 성격과 책임을 가진 것들끼리 묶을 수 있다. 나누지 않는다면 코드가 지저분해지는 등 많은
 문제점이 발생한다. 그래서 성격이 다른 것은 아키텍처 분리해주는 게 좋다. 
* 분리된 각 오브젝트는 독자적으로 개발과 테스트가 가능해서 개발과 변경 작업이 모두 빨라질 수 있다. 
* 구현 방법이나 세부 로직은 서로 영향을 주지 않고 변경될 수 있을 만큼 유연하다.

==> 이렇게 책임과 성격이 다른 것을 분리하는 것을 아키텍처 차원에서 **계층형 아키텍처(layered architecture)** 라고 부른다.
(또는 멀티 티어(=계층) 아키텍처 / 3계층 애플리케이션)
* 웹 기반의 엔터프라이즈 애플리케이션은 일반적으로 세 개의 계층을 갖지만 반드시 그런 것은 아니다.


**3계층 아키텍처와 수직계층**

3계층 아키텍처 구분(애플리케이션에서 담당하는 역할에 따라 분류)
* 데이터 엑세스 계층: DB나 레거시 시스템과 연동하는 인터페이스 역할을 함
* 서비스 계층: 비즈니스 로직을 담고 있음
* 프레젠테이션 계층: 주로 웹 기반의 UI를 만들어내고 그 흐름을 관리하는 프레젠테이션 계층으로 구분한다.

![image](https://user-images.githubusercontent.com/48270067/155341577-26d2b4fd-133f-4a94-84bb-f4df05d91d06.png)

=> 각 계층을 부르는 다양한 이름을 정리해둔 그림


<데이터 엑세스 계층>

* DAO 패턴을 보편적으로 사용하기 때문에 DAO 계층이라고도 불린다. 
* DB 외에도 ERP, 레거시 시스템, 메인프레임 등에 접근하는 역할을 하기 때문에 EIS(Enterprise Information System) 계층이라고도 한다. 
* 장기적인 데이터 저장을 목적으로 하는 DB 이용이 주된 책임
* 외부 시스템을 호출하는 것은 기반 계층으로 따로 분류하기도 한다. 

![image](https://user-images.githubusercontent.com/48270067/155341893-1c576fdc-9e5f-43a0-9ab7-c25a9cb20a1c.png)

* 사용 기술에 따라서 다시 세분화된 계층으로 구분될 수 있다. 
  * 추상화 수준에 따른 구분이므로 **수직적인 계층**이라고 부른다.
  * 세로로 배열
* JdbcTemplate을 사용하는 데이터 액세스 계층의 특징은 JdbcTemplate이 추상화를 위한 계층으로 사용돼서 로우레벨의 기반 계층에 존재하는 JDBC와 드라이버, 스프링의 트랜잭션 추상화 서비스의 동기화 기능을 간접적으로 이용하게 만든다는 것이다. 
* 추상화 계층구조를 따른다면 항상 JdbcTemplate을 통해 접근하도록 코드를 작성하는 것이 바람직하다. 추상화 계층은 필요하면 얼마든지 추가할 수 있다. 
* JdbcTemplate 기능과 SqlService의 SQL을 가져오는 기능을 묶어서 더 단순한 방법으로 DAO코드를 작성하고 싶다면 또 하나의 추상계층을 추가할 수 있다.

<서비스 계층>

서비스 계층은 구조로 보자면 가장 단순하다. 잘 만들어진 스프링 애플리케이션의 서비스 계층 클래스는 이상적인 POJO로 작성된다. POJO 만든다면 객체지향적인 설계 기법이 적용된 코드를 통해서 비즈니스 로직의 핵심을 잘 담아내고, 이를 쉽게 테스트하고 유연하게 확장할 수 있다.

서비스 계층은 DAO 계층을 호출하고 이를 활용해서 만들어진다. 때론 데이터 액세스를 위한 기능 외에 서버나 시스템 레벨에서 제공하는 기반 서비스를 활용할 필요도 있다.

서비스 계층은 틀별한 경우가 아니라면 추상화 수직 계층구조를 가질 필요가 없다. 
기술 API를 직접 다루는 코드가 아니기 때문에 기술에 일관된 방식으로 접근하게 하거나 편하게 사용하게 해주는 추상화는 필요없기 때문이다.

시스템 레벨이나 다른 서버에서 제공하는 기반 서비스를 사용할 때도 DAO처럼 독립적인 계층의 서비스를 이용하는 것으로 봐야한다. 

원칙적으로는 서비스 계층 코드가 기반 서비스 계층의 구현에 종속되면 안된다. 
* 서비스 계층의 코드는 추상화된 기반 서비스 인터페이스를 통해서만 접근하도록 만들어서 특정 구현과 기술에 종속성을 제거해야 한다. 
* 또는 AOP를 통해서 서비스 계층의 코드를 침범하지 않고 부가기능을 추가하는 방법을 활용

==> 이상적인 서비스 계층은 데이터 엑세스 및 프레젠테이션 계층이 모두 바뀌어도 유지될 수 있어야한다. 


<프레젠테이션 계층>

이 계층을 가장 복잡한 계층으로 매우 다양한 기술과 프레임워크의 조합을 가질 수 있다. 
웹과 프레젠테이션 기술을 끊임없이 발전하고 새로운 모델이 등장하기 때문이다.
* 클라이언트의 종류와 상관없이 HTTP 프로토콜을 사용하는 서블릿이 바탕이 된다. 
* 다른 계층과 달리 클라이언트까지 그 범위를 확장될 수도 있다. 
* 초기 클라이언트 모델은 단순히 HTML로 만들어진 결과를 사람이 볼 수 있도록 그려주고, 폼을 통해 입력받은 값을 전달하는 것이었다. 
* 하지만 최근에는 점점 많으 프레젠테이션 로직이 클라이언트로 이동하고 있다.

**계층형 아키텍처 설계의 원칙**

오브젝트와 그 관계에 적용했던 대부분의 객체지향 설계의 원칙은 아키텍처 레벨의 계층과 그 관계에도 동일하게 적용될 수 있다. 
각 계층은 응집도가 높으면서 다른 계층과는 낮은 결합도를 유지할 수 있어야한다. 
* 각 계층은 자신의 계층의 책임에만 충실해야하고 자신과 관련된 기술이 아닌 다른 기술 API의 사용을 삼가해야 한다. => 충실한 계층을 만들면 각 계층 사이의 결합도는 자연스럽게 낮아진다. 
* 특정 계층에서 필요한 작업을 다른 계층에게 부탁할 때, 계층 레벨에서 정의한 인터페이스를 통해서 요청하고 다음과 같이 그 인터페이스 메소드에서는 특정 계층의 기술이 드러나면 안된다.

👀!!!!!!!!!!!!!!!!!!!!

프레젠테이션 계층의 오브젝트를 그대로 서비스 계층으로 전달하면 안된다.
계층의 경계를 넘어갈 때는 반드시 특정 계층에 종속되지 않는 오브젝트 형태로 변환해줘야한다. 

==> 그럼 Controller에서 파라미터로 받은 request 객체를 그대로 Service 함수 호출할때 넘겨주면 안된다는 건가???
Mapper 사용??


### 애플리케이션 정보 아키텍처

엔터프라이즈 시스템은 본질적으로 동시에 많은 작업이 빠르게 수행돼야 하는 시스템이다.

애플리케이션의 주요 상태정보는 클라이언트나 백엔드 시스템에 분산돼서 보관된다. 비교적 장기간 보관되는 상태정보는 주로 DB나 메인프레임 같은 EIS백엔드 시스템에 저장된다. 하나의 업무 작업이 여러 번의 요청과 페이지에 걸쳐 일어나는 경우에 유지돼야 하는 임시 상태정보는 클라이언트에 일시적으로 보관되기도 하고 서버의 사용자별 세션 메모리에 저장되기도 한다.

애플리케이션을 사이에 두고 흘러다니는 정보를 어떤 식으로 다룰지를 경장하는 일도 아키텍처를 결정할 때 매우 중요한 기준이 된다.
* 애플리케이션에 존재하는 정보를 단순히 데이터로 다루는경우
* 애플리케이션에 존재하는 정보를 오브젝트로 다루는 경우

**DB/SQL 중심의 로직 구현 방식**

데이터 중심 구조는 하나의 업무 트랜잭션에 모든 계층의 코드가 종속되는 경향이 특징이다.

이름으로 사용자 정보를 검색하여 사용자의 아이디, 비밀번호, 이름, 가입일자를 보여주는 작업이 하나의 업무 단위가 되면 사용자 조회라는 단위 업무를 위해서만 존재하는 각 계층의 코드가 만들어진다
 이 아키텍처에서 검색 조건은 SQL로 만들어진다. SQL 결과를 맵이나 객체로 프레젠테이션 계층에 전달된다고 했을 때, 서비스 계층은 별로 할 것이 없고, 프레젠테이션 계층의 해당 뷰는 SQL에서 정확히 어떤 필드값을 리턴할지, 어떤 포맷으로 전달하는지 알고 있다. 프레젠테이션 계층에서는 DB에서 돌려준 값을 그대로 사용한다. 
 
 따라서 이런 구조는 **하나의 특정 업무에 모든 계층의 코드가 종속**되며 업무의 내용이 바뀌면 모든 계층의 코드가 함께 변경된다.
 
 
이런 식의 개발 방법과 아키텍처는 자바 기술이 발전하기 이전의 엔터프라이즈 시스템에서 흔히 발견할 수 있다.
2계층 구조에서도 비슷하게 발견할 수 있다.


이런 방식은 **자바 코드를 단지 DB와 웹 화면을 연결해주는 단순한 인터페이스 도구로 전락**시키는 것이다. 자바의 오브젝트는 단지 HTTP 서비스 채널을 만들어고 JDBC를 이용해 DB기능을 사용하게 하는 스크립트 정도로 역할이 축소 된다.

**거대한 서비스 계층의 방식**

DB에서 가져온 데이터가 애플리케이션에 흘러다니는 정보의 중심이 되는 아키텍처이긴 하지만 DB에 저장 프로시저의 사용을
자제하고 복잡한 WQL을 피하면서, 주요 로직은 서비스 계층의 코드에서 처리하도록 만드는 방법이다.
많은 비즈니스 로직을 DB 저장 프로시저에서 서비스 계층의 오브젝트로 옮겨 왔기 때문에 구조는 단순해지고 객체지향 개발의 장점을 살릴 기회가 많아진다.

장점
* 애플리케이션의 코드에 비즈니스 로직이 담겨 있기 때문에 자바 언어의 장점을 활용해 로직을 구현할 수 있고 테스트하기도 수월하다는 점
* DAO가 다루는 SQL이 복잡하지 않고 프레젠테이션 계층의 뷰와 1:1로 매핑되지 않아도 되기 때문에 일부 DAO 코드는 여러 비즈니스 로직에서 공유해서 사용할 수 있다. 


단점
* 데이터 액세스 계층의 SQL은 서비스 계층의 비즈니스 로직의 필요에 따라 만들어지기가 쉬워 계층 간의 결합도가 크다
* 서비스 계층의 메소드는 업무 트랜잭션 단위로 만들어지기 때문에 비슷한 기능의 코드가 여러 메소드에서 중복되서 나타나기 쉽다.

### 오브젝트 중심 아키텍처

오브젝트 중심 아키텍처가 데이터 중심 아키텍처와 다른 가장 큰 특징은 도메인 모델을 반영하는 **오브젝트 구조를 만들어두고 그것을 각 계층 사이에서 정보를 전송**하는 데 사용한다는 것이다. 그래서 오브젝트 중심 아키텍처는 객체지향 분석과 모델링의 결과로 나오는 도메인 모델을 오브젝트 모델로 활용한다.

오브젝트 중심 아키텍처: 오브젝트를 만들어두고 오브젝트 구조 안에 정보를 담아서 각 계층 사이에 전달하게 만드는 것

**데이터와 오브젝트**

데이터 중심의 아케텍처에서는 DAO가 만드는 SQL의 결과에 모든 계층의 코드가 의존하게 된다. 
(서비스 계층이나 프레젠테이션 계층의 코드에서는 어떻게 저장을 했는지 알아야 사용할 수 있고 DAO에서 필드 이름이나 개수를 바꾼다면 두 계층의 코드도 같이 변경돼야한다. )

오브젝트 중심 아키텍처에서는 애플리케이션에서 사용하는 정보가 도메인 모델의 구조를 반영해서 만들어진 객체 안에 담긴다. 
도메인 모델은 애플리케이션 전 계층에서 동일한 의미를 갖기 때문에 이 객체는 전 계층에서 일관된 구조를 유지한 채로 사용할 수 있다. 
* 오브젝트 구조를 만드려면 DB에서 가져온 데이터를 도메인 오브젝트 구조에 맞게 변환해줄 필요가 있다. 
* 서비스/프레젠테이션 계층에서는 DAO에서 어떤 sQL을 사용했는지, 어떤 방식으로 DB에서 조회를 했는지 알 필요가 없다. 

**도메인 오브젝트 사용의 문제점**

* 최적화된 SQL을 매번 만들어 사용하는 경우에 비해 성능 면에서 조금은 손해를 감수해야 할 수도 있다. 
 * DAO는 비즈니스 로직의 사용 방식을 알지 못하므로, 도메인 오브젝트의 모든 필드 값을 다 채워서 전달하는 경우가 대부분이다. 어떤 비즈니스 로직에서 필요한 정보가 몇 개의 필드 뿐이라면 DAO에서 도메인 오브젝트의 모든 필드 정보를 채워서 전달하는 것은 낭비일 수도있다.

이런 문제를 해결하는 접근 방법으로 지연된 로딩(lazy loading) 기법을 이용하면 일단 최소한의 오브젝트 정보만 읽어두고 관계하고 있는 오브젝트가 필요한 경우에만 다이내믹하게 DB에서 다시 읽어올 수 있다.


가장 좋은 방법은 JPA나 JDO와 같은 오브젝트/RDB 매핑(ORM) 기술을 사용하는 것이다. 이런 데이터 액세스 기술은 기본적으로 지연된 로딩 기법 등을 제공해주기 때문에 번거로운 코드를 만들지 않고도 도메인 오브젝트의 생성을 최적화할 수 있다.

그래서 도메인 오브젝트를 사용하는 오브젝트 중심 아키텍처에서는 가능하다면 ORM과 같은 오브젝트 중심 데이터 액세스 기술을 사용하는 것을 권장한다.



다시 정리하자면 오브젝트 중심의 아키텍처는 도메인 모델을 따르는 오브젝트를 사용해 각 계층 사이에 정보를 전달하고, 이를 이용해 비즈니스 로직이나 프레젠테이션 로직을 작성한다. 그런데 모델인 오브젝트는 자바 오브젝트로 데이터를 저장하기 위해서만 사용하는 것이 아닌 내부 정보를 이용하는 기능도 함께 갖고 있어야한다. (클레스 = 속성 + 행위)

오브젝트 중심 아키텍처를 도메인 오브젝트의 활용 방법을 기준으로 구분해 보자.

* 빈약한 도메인 오브젝트 방식
 * 도메인 오브젝트에 정보만 있고 활용하는 기능이 없다면 온전한 오브젝트라고 보기 힘들어 **빈약한 오브젝트**라고 부른다.
 * 흔히 사용
 * 활용하는 기능이라고 하면 도메인의 비즈니스 로직이라고 할 수 있다. 서비스 계층에 존재한다. 
 * 다루는 정보의 구조가 다를 뿐이지 거대 서비스 계층구조와 비슷하다. 한계점도 비슷하다.
 * 여전히 서비스 계층의 메소드에 대부분의 비즈니스 로직이 들어 있기 때문에 로직의 재사용성이 떨어지고 중복의 문제가 발생하기 쉽다. 
* 풍성한 도메인 오브젝트 방식
 * 영리한 도메인 오브젝트
 * 빈약한 도메인 오브젝트의 단점을 극복하고 도메인 오브젝트의 객체지향적인 특징을 잘 사용할 수 있도록 개선한 것이다. 
 * 서비스 계층의 코드가 아닌 도메인 오브젝트에 도메인 오브젝트와 관계가 있는 로직을 넣어주고, 서비스 계층의 비즈니스 로직에서 재사용하게 만드는 것
 * 데이터와 그것을 사용하는 기능이 한 곳에 모여 있기 때문에 응집도가 높다. 
 * 이 방식에서 서비스 계층에서는 여러 도메인 객체의 기능들을 조합해서 복잡한 처리를 수행하거나, 데이터 엑세스 계층, 다른 기반 계층을 호출할 필요가 있는 로직을 구현한다. 
 * 도메인 오브젝트는 직접 데이터 엑세스 계층이나 기반 계층 또는 다른 서비스 계층의 오브젝트에 접근할 수 없기 때문에 서비스 계층이 필요하다. DAO 오브젝트를 DI 받아서 사용할 수 있어야하는데 그럴 수 없다. 왜냐하면 도메인 오브젝트는 스프링 컨테이너가 관리하는 오브젝트, 즉 빈이 아니기 때문이다. 필요에 따라 새롭게 만들어지는 오브젝트이다. 그래서 DAO와 기반계층 오브젝트를 DI 받아 사용할 수 있는 서비스 계층의 코드가 필요하다. 
 * 빈약한 도메인 오브젝트 방식보다 서비스 계층의 코드가 간결하다. 
* 도메인 계층 방식
 * 도메인 오브젝트가 스스로 필요한 정보는 DAO를 통해 가져올 수 있고, 생성이나 변경이 일어났을 때 직접 DAO에게 변경사항을 반영해달고 요청할 수는 없을까? 
 * 메인 오브젝트가 기존 3계층과 같은 레벨로 격상되어 하나의 계층을 이루게 하는 도메인 계층 방식이다.
 * 도메인 오브젝트가 독립된 계층을 이뤘기 때문에 기존 방식과는 다른 두 가지 특징을 갖게 된다.
  * 도메인에 종속적인 비즈니스 로직의 처리는 서비스 계층이 아니라 도메인 계층의 오브젝트 안에서 진행된다는 점
  * 도메인 오브젝트가 기존 데이터 액세스 계층이나 기반 계층의 기능을 직접 활용할 수 있다는 것이다.(AOP가 필요하다. )
 * 이전의 어떤 방식보다 도메인 오브젝트에 많은 비즈니스 로직을 담아낼 수 있지만 서비스 계층의 역할이 완전히 사라지는 것은 아니다. 


도메인 오브젝트를 독립적인 계층으로 만들려고 할 때 고려해야 할 중요한 사항이 있다. 도메인 오브젝트가 도메인 계층을 벗어나서도 사용되게 할지 말지 결정해야 한다. 도메인 오브젝트가 계층을 이루기 전에는 모든 계층에 걸쳐 사용되는 일종의 정보전달 도구 같은 역할을 했다.

선탤할 수 있는 방법은 두가지가 있다. 

* 모든 계층에서 도메인 오브젝트를 사용한다. 
 * 도메인 계층, 서비스 계층, 프레젠테이션 계층, 뷰에서도 직접 도메인 오브젝트를 전달받아 사용할 수 있게 하는 것이다. 
 * 도메인 모델을 따르는 오브젝트 구조를 활용하는 면에서 오브젝트 중심 아키텍처의 장점을 그대로 누릴 수 있다. 
 * 하지만 주의하지 않으면 이를 함부로 사용하는 위험이 뒤따를 수 있다. => 철저한 가이드라인을 두고 적용하는 것이 필요하다.
* 도메인 오브젝트는 도메인 계층을 벗어나지 못하게 하는 것이다. 
 * 도메인 계층 밖으로 전달될 때는 별도로 준비된 정보 전달용 오브젝트에 도메인 오브젝트의 내용을 복사해서 넘겨줘야한다. 이런 오브젝트를 DTO라고한다.
 * DTO는 변화를 허용하지 않고 읽기전용으로 만들어지기도 한다.
 * DTO는 기능을 갖지 않으므로 사용하기 안전하다.
 * 반면에 도메인 오브젝트와 비슷한 구조를 가진 오브젝트를 따로 만들어야 하고 이를 매번 변환해줘야하는 번거로움이 있다. => AOP와 같은 방법을 이용해 변환을 자동으로 해주도록 만들 필요가 있다. 


이 두 가지 방법 중 어느것이 더 낫다고 말하기는 힘들다.


---

마지막으로 정리해 보자면,

스프링은 어떤 플랫폼에서도 사용될 수 있지만, 기본적으로는 자바 엔터프라이즈 플랫폼(JAVAEE)에 최적화되어 있다. HTTP를 통해 접근하는 웹 클라이언트와 백엔트 DB를 사용하는 애플리케이션에 적합하다. 

스프링 애플케이션은 역할에 따라 3계층으로 구분되고, 다시 기술의 추상도에 따라 세분화 되는 계층형 아키텍처를 사용하는 것이 좋다. 

아키텍처는 애플리케이션이 다루는 정보의 관점에서 데이터 중심과 오브젝트 중심으로 구분할 수 있으면 스프링에 가장 잘 어울리는 아키텍처는 오브젝트 중심의 아키텍처이다. 
















