## 4장 예외

모든 예외는 적절하게 복구되든지 아니면 작업을 중단시키고 운영자 또는 개발자에게 통보되어야 한다.

하지 말아야 할 것: 예외를 무시하는 것, 무의미하고 무책임한 throws 선언

---

### 예외의 종류와 특징

자바에서 throw를 통해 발생시킬 수 있는 예외는 크게 세 가지가 있다. 

#### 1. Error
시스템에 비정상적인 상황이 발생했을 때 사용된다. 그래서 주로 자바 VM에서 발생시키는 것이고 애플리케이션에서는 이런 에러에 대한 처리는 신경 쓰지 않는다. ( 대응 방법이 없기 때문 )

==> 그럼 어떻게 대응해야 할까?

Error와 예외를 구분해야 할 필요가 있다. 

* Error는 시스템이 종료되어야 할 수준의 상황과 같이 수습할 수 없는 심각한 문제를 의미한다. 개발자가 예측하여 방지할 수 없다. 
* Exception은 개발자가 구현한 로직에서 발생한 실수나 사용자의 영향에 의해 발생한다. 오류와 달리 개발자가 예측하여 방지할 수 있으므로 상황에 맞는 예외 처리를 해야 한다.

#### 2. Exception(예외)

Exception 클래스는 체크 예외와 언체크 예외(Unchecked exception)로 구분된다. 

* 체크 외

복구될 가능성이 있는 문제 상황을 체크 예외라고 한다. catch/throw가 필요하다.

ex) IOException, SQLException

* 언체크 예외 - 런타임 예외라고 부르기도 한다.

RuntimeException을 상속한 클래스들이다. 개발자가 부주의해서 발생할 수 있는 경우에 발생하게 한 것이 런타임 예외이므로 굳이 catch나 throws를 사용하지 않아도 된다. (피할 수 있기 때문)

발생하지 않도록 설계하는 것이 우선

ex) NullPointerException, IllegalArgumentException

### 예외처리 방법

예외를 처리하는 일반적인 방법

1. 예외 복구

예외상황을 파악하고 문제를 해결해서 정상 상태로 돌려놓는 것이다.

예를 들어 사용자가 요청한 파일을 읽으려고 시도했는데 해당 파일이 없어서 IOException이 발생했을 때 사용자에게 상황을 알려주고 다른 파일을 이용하도록 안내해서 예외상황을 해결할 수 있다.

==> 다른 작업 흐름으로 자연스럽게 유도하기

2. 예외처리 회피

 예외 처리를 자신이 담당하지 않고 자신을 호출한 쪽으로 던져버리는 것
 
 3. 예외 전환( exception translation )

예외를 적절한 예외로 전환해서 던진다. 두 가지 목적이 있다.

* 의미가 분명해지도록 추상화하는 것

ex) SQLException을 DuplicateUserIdException로 전환: 새로운 사용자를 등록하려고 시도할 때 아이디가 중복일 때 DB 에러가 발생하면서 SQLException을 발생시킨다. 
이대로 밖으로 던져버리면 서비스 계층에서는 왜 발생했는지 쉽게 알 방법이 없으므로 DAO에서 정보를 해석해서 DuplicateUserIdException 같은 예외로 바꿔서 던져주는 것이 좋다.

* 예외를 처리하기 쉽고 단순하게 만들기 위해 포장(Wrapping)하는 것
주로 체크 예외를 언체크 예외인 런타임 예외로 바꾸는 경우에 사용한다. 

==> 복구할 수 없는 예외라면 가능한 한 빨리 런타임 예외로 포장해 던지게 해서 다른 계층의 메소드를 작성할 때 불필요한 throws 선언이 들어가지 않도록 해줘야함 
기타 서비스를 이용해 자세한 로그를 남기면서 메일로 관리자에게 통보하고, 사용자에게 친절한 안내 메세지를 보이는 게 바람직함

#### 예외처리 전략

##### 런타임 예외의 보편화

자바의 환경이 서버로 이동하면서 체크 예외의 활용도와 가치가 떨어지고 있다. ( throws Exception으로 점철된 메소드를 낳을 수 있기 때문)
대응이 불가능한 체크 예외라면 런타임 예외로 전환해서 던지는 게 낫다.

최근에 등장하는 표준 스펙 또는 오픈소스 프레임워크에서는 API가 발생시키는 예외를 체크 예외 대신 언체크 예외로 정의하는 것이 일반화되고 있다. 
언체크 예외라도 필요하다면 얼마든지 catch 블록을 잡아서 복구하거나 처리할 수 있기 때문이다.

==> 일관된 예외 처리 전략을 정리해 보자면 대개 언체크 예외로 사용한다.


##### 애플리케이션 예외 처리

시스템 또는 외부의 예외상황이 원인이 아니라 애플리케이션 자체의 로직에 의해 의도적으로 발생시키고 반드시 catch해서 조치하도록 요구하는 예외를 애플리케이션 예외라고 한다. 

ex) 정상적인 출금처리 / 잔고 부족 
* -> 다른 종류의 리턴 값을 돌려주는 것
* -> 정상적인 흐름을 따르는 코드는 그대로 두고 잔고 부족과 같은 예외 상황에서는 비즈니스적인 의미를 띤 예외를 던지도록 만드는  

==> 애플리케이션 예외의 처리는 custom error code 또는 custom exception

##### JdbcTemplate 

JdbcTemplate을 적용하는 중에 throws SQLException 선언이 왜 사라졌는가?

JdbcTemplate 템플릿/콜백 안에서 발생하는 모든 SQLException이 RuntimeException을 상속한 DataAccessException으로 wrapping 되어있기 때문이다.
* 대부분 복구가 불가능한 예외인 SQLException에 대해 애플리케이션 레벨에서 신경 쓰지 않도록 해줌
* SQLException에 담기 힘든 상세한 예외정보를 의미 있고 일관성 있는 예외로 전환해서 추상화해주려는 용도로 쓰이기도 함

#### JDBC의 한계

DB에 관계없이 자유롭게 사용할 수 없다. 

1. 특정 DB에만 있는 비표준 SQL들을 사용한다면, 다른 DB로 갈아끼울 때 SQL을 한바탕 뒤집어 함
2. SQLException 하나로 모든 예외가 압축되기 때문에 e.gerErrorCode() 등으로 에러 코드를 확인해야만 정확한 에러를 확인할 수 있다. 그런데 각 DB는 서로 다른 에러 코드를 사용한다. (=> 데이터 엑세스 기술에 의존적인 코드가 된다.)

```java
public void add(User user) throws SQLException; //Jdbc api
public void add(User user) throws PersistentException; //JPA
public void add(User user) throws HibernateException; //Hibernate
```

=> 2번 문제를 해결하기 위해서 스프링의 JdbcTemplate에서는 최종 예외로 DataAccessException을 두고, 다양한 데이터 액세스 기술을 사용할 때 발생하는 예외들을 추상화해서 DataAccessException 계층구조 안에 정리해놓았다.


DataAccessException 계층구조는 의미가 같은 예외라면 데이터 엑세스 기술의 종류와 상관없이 일관된 에러가 발생하도록 만들어준다.

